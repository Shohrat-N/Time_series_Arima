# -*- coding: utf-8 -*-
"""Untitled24.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sMYNgi990x3X0FwMjivwlZ4LDD2tX_YU

Through Arima model, the number of people in Azerbaijan is forecasted for the next 7 years with the dataset.


dataset: https://www.macrotrends.net/countries/AZE/azerbaijan/population#:~:text=The%20population%20of%20Azerbaijan%20in,a%200.79%25%20increase%20from%202018

# Import Libaries
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.stats.diagnostic import acorr_ljungbox
from statsmodels.tsa.arima_model import ARIMA
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.graphics.tsaplots import plot_acf,plot_pacf
from statsmodels.graphics.gofplots import qqplot

"""# Import Dataset"""

data=pd.read_excel("/content/Population_76.xlsx")

"""# Data Understanding"""

# check first 5 rows
data.head()

# check size of dataset
data.shape

#check null values
data.isnull().sum()

#check data types
data.dtypes

# change year column type into date
data.Year=data.Year.astype(int).astype(str) + '-01-01'
data.Year=pd.to_datetime(data.Year)

# sort values by ascending
data.sort_values(by='Year', ascending=True, inplace=True)
data.head()

# see statistics properties
data.describe().transpose()

# Visualize Descriptive Statistics

# get numeric columns
num_col = data._get_numeric_data().columns

describe_num_df = data.describe(include=['int64','float64'])
describe_num_df.reset_index(inplace=True)
# To remove any variable from plot
describe_num_df = describe_num_df[describe_num_df['index'] != 'count']
for i in num_col:
  if i in ['index']:
    continue
  sns.factorplot(x='index', y=i, data=describe_num_df)
  plt.show()

# make Year column index 
data.set_index('Year', drop=True, inplace=True)

#Visualize Population column
sns.set_style('darkgrid')
data.Population.plot(color='green', figsize=(16, 8))
plt.title('Azerbaijani Population over Years')

"""# Decompasition"""

decomposition=seasonal_decompose(data['Population'])
fig = plt.figure()  
fig = decomposition.plot()  
fig.set_size_inches(15, 8)

"""From the graph we can see that the entire series is taken as the trend component and that there is no seasonality. We can also see that the residual plot shows around zero.

# Testing for Stationarity
"""

result = adfuller(data['Population'])
print('ADF test statistic:', result[0]),
print('p value:', result[1])
print('Critical Values:', result[4])

# KPSS Test
result_kpss = kpss(data.Population)
print('KPSS Statistic:', result_kpss[0]),
print('p-value:', result[1]),
print('Critical Values:', result[4])

"""According to the results of Adfuller and KPSS tests, given the p values that are more than 0.05, we fail to reject Null Hypothesis that is data is non-stationary. It needs transformation."""

# transform the data
adfuller_diff = np.diff(data['Population'], n=1)

ad_fuller_result = adfuller(adfuller_diff)

print(f'ADF Statistic: {ad_fuller_result[0]}')
print(f'p-value: {ad_fuller_result[1]}')

"""# Autocorrelation"""

fig = plot_acf(data['Population'].diff().dropna())

fig = plot_pacf(data['Population'].diff().dropna(), lags=15)

"""Main priority here is to try to figure out whether will be used the AR or MA components for the ARIMA model (or both!) as well as how many lags we should use. While building the model I will use AR(2).

"If the autocorrelation plot shows positive autocorrelation at the first lag (lag-1), then it suggests to use the AR terms in relation to the lag

If the autocorrelation plot shows negative autocorrelation at the first lag, then it suggests using MA terms".

### Figure out Order for Arima
"""

import statsmodels
import statsmodels.api as sm
import statsmodels.formula.api as smf

!pip install pmdarima

#import Library for auto_arima
from pmdarima import auto_arima
# Ignore harmless warnings
import warnings
warnings.filterwarnings("ignore")

# With Auto Arima check p, d, q
order= auto_arima(data, 
                          suppress_warnings=True)           
order.summary()

fig = order.plot_diagnostics(figsize=(10,8))

"""According to the graph and Ljung-Box test, we reject to Null Hypothesis that residuals are uncorrelated. That's why I'll not be able to use this model.

# Data Splitting
"""

# split data as train and test
train=data[:60]
test=data[60:]

#check size of train dataset
train.shape

# check size test dataset
test.shape

# build model with p=2, q=1, m=0
model_arima=ARIMA(train, order=(2, 1, 0))
model_arima_fit=model_arima.fit()

print(model_arima_fit.summary())

"""I will also run the model diagnostics to check for the assumptions Normality of errors and the distribution of residuals. So the errors are should be normally distributed and uncorrelated to each other."""

# check residuals 
residuals = model_arima_fit.resid
acorr_ljungbox(residuals, np.arange(1, 11, 1), return_df=True)

"""As p-value is more than 0.05, we fail to reject Null Hyphotesis that residuals are uncorrolated"""

#  visualize residuals distribution
plt.figure(figsize=(12, 8))
plt.subplot(3, 1, 1)
model_arima_fit.resid.plot()

plt.subplot(3, 1, 3)
model_arima_fit.resid.plot(kind='kde')

# predict train dataset
model_arima_fit.plot_predict(dynamic=False)
plt.show()

# check the model with test dataset
start=len(train)
end=len(train)+len(test)-1
pred=model_arima_fit.predict(start=start,end=end,typ='levels').rename('ARIMA predictions')
data["Prediction"]=model_arima_fit.predict(start=start,end=end,typ='levels')
pred.plot(legend=True)
test['Population'].plot(legend=True)

data.tail(13)

#  check measure of prediction accuracy with mean absolute percentage error
from sklearn.metrics import mean_absolute_percentage_error
from math import sqrt
mape=sqrt(mean_absolute_percentage_error(test['Population'], pred))
print(mape)

"""# Forecasting"""

# fit the model
model2=ARIMA(data['Population'],order=(2,1,0))
model2=model2.fit()

#forecast next 7 years
forecast=model2.predict(start=len(data), end=len(data)+7,typ='levels').rename('Forecasting')
#print(comp_pred)

print(forecast)

# Visualize the result of the forecast
plt.figure(figsize=(16, 8))
forecast.plot(legend=True)
data['Population'].plot(legend=True)